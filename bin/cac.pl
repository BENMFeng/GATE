#!/usr/bin/perl -w
use strict;
use Getopt::Long;

my %opts;
my ($Help,$Lengc,$Length,$Format,$Sort,$Stat_report,$Ref);
GetOptions(
	\%opts,
	"lgc:s"=>\$Lengc,
	"L:i"=>\$Length,
	"f:s"=>\$Format,
	"sort"=>\$Sort,
	"ref:s"=>\$Ref,
	"stat:s"=>\$Stat_report,
	"help"=>\$Help
);

if ((defined $Help)||(!defined $Format)||(@ARGV==0))
{
	die "Calculate Alignment file Average Coverage\nAuthor: BENM <binxiaofeng\@gmail.com> Version: 3.85 Update 2012-03-21\n

cac <IN:mapview|soap> [-lgc Len_GC file] [-L genome_length] [-f MAQ|SOAP|BWA|BOWTIE|SAM|BAM|BLAST-m8|BLAT-psl|Eland] [-sort] [-ref subject|query, default:subject] [-stat output_prefix]\n

Note: (1) The Alignment file should be sort by reference sequences' name and position
          You can sort this file use msort, for example: msort -k 8,n9 aln.soap > aln.soap.sort
          Or you can use \"-sort\" option to do this, and it will output an sort file with \".sort\" suffix file\n
      (2) Len_GC file could be generated by calengc.pl, Format: \"scaffold00001      Length: 2180\"\n
      (3) If input file is in BLAST-m8 format, it should be sort by program, so it doesn't need to set \"-sort\"\n
      (4) If input file is in BLAT-psl format, it needs to set \"-sort\", but it doesn't need to set \"-lgc\"\n
      (5) \"-ref\" just works at \"-f\" is BLAST or BLAT options\n
      (6) If defined \"-stat\" it will output the distribution of alignment consensus length and gap block size\n

Example:
1. cac aln.map -lgc ref.lengc -f MAQ
2. cac aln.mapview -lgc ref.lengc -f MAQ
3. cac blat.psl -f BLAT-psl -ref query
4. cac blast.m8 -f BLAST-m8.tab -lgc ref.lengc -stat BLAST\n";
}

## SOAP
## 149890  GCTTTGTGATAACCAAAAAAGAATTGATTTATTA      [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[      3       a       34      -       chr10   63260   1       0       0

## MAQ
## HWI-EASE2_4_13243:6:99:472:363  chr10   50053   +       426     18      0       0       0       0       0       2       1       35      TTCTGAATGACATttactttggtgctctttatttt     @@@@@@@@@@@@@;;;;;;;7;;;;;;;;;;;666

## BWA
## @SQ     SN:Manihot_esculenta_chloroplast        LN:161453
## HWI-EAS737:8:1:0:1198#0 73      Manihot_esculenta_chloroplast   878     25      76M     =       878     0       NATGCATAGCACTGAATAGGGAGCCGCCGAATACACCAGCTACGCCTAACATGTGAAATGGGTGCATAAGGAGNGT DMUWUWUWVWVUWWWWUURWUYYSWWWUWYWXWWYWYYWWYYWSWUWTVWWWUYWWUWWWBBBBBBBBBBBBBBBB XT:A:U  NM:i:4  SM:i:25 AM:i:0  X0:i:1  X1:i:0  XM:i:4  XO:i:0  XG:i:0  MD:Z:0C71T0G0T1
## HWI-EAS737:8:1:0:1198#0 133     Manihot_esculenta_chloroplast   878     0       *       =       878     0       NCTGTTTTCTTGATCTATCCAATTGGGCAGGGAANCGNNTNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN DOZYRWZYVYWWURVWZTWUWWBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB

## BOWTIE
## @HD     VN:1.0  SO:unsorted
## @SQ     SN:Manihot_esculenta_chloroplast        LN:161453
## @PG     ID:Bowtie       VN:0.12.3       CL:"/home/bio/biosoft/Alignment/bowtie/bowtie-0.12.3/bowtie Manihot_esculenta_chloroplast -q -1 s_8__1_sequence.txt -2 s_8__2_sequence.txt --phred64-quals -S"
## HWI-EAS737:8:1:0:1198#0/1       +       Manihot_esculenta_chloroplast   877     NATGCATAGCACTGAATAGGGAGCCGCCGAATACACCAGCTACGCCTAACATGTGAAATGGGTGCATAAGGAGNGT %.6868687876888866386::488868:8988:8::88::84868578886:886888################    0       0:C>N,72:T>G,73:G>N,74:T>G
## HWI-EAS737:8:1:0:1198#0/2       -       Manihot_esculenta_chloroplast   982     NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNANNCGNTTCCCTGCCCAATTGGATAGATCAAGAAAACAGN ######################################################88685;873688:7:;83:;0%    0       0:C>N,26:A>C,34:C>N,36:A>C,37:A>N,38:A>N,40:G>N,41:A>N,42:C>N,43:T>N,44:A>N,45:C>N,46:C>N,47:A>N,48:T>N,49:A>N,50:C>N,51:G>N,52:G>N,53:A>N,54:G>N,55:A>N,56:T>N,57:C>N,58:C>N,59:T>N,60:T>N,61:A>N,62:G>N,63:A>N,64:G>N,65:A>N,66:C>N,67:C>N,68:A>N,69:T>N,70:G>N,71:A>N,72:A>N,73:A>N,74:G>N,75:T>N

## BLAST m8/m9
## MH001A19_F_ctg740_9000-ctg740_142000_length=462 scaffold10378_length=2677       97.73   44      0       1       1       44  547      505     4e-11   71.9
## Fields: Query id, Subject id, % identity, alignment length, mismatches, gap openings, q. start, q. end, s. start, s. end, e-value, bit score

## BLAT
## psLayout version 3
##
## match   mis-    rep.    N's     Q gap   Q gap   T gap   T gap   strand  Q               Q       Q       Q       T               T       T       T       block   blockSizes   qStarts  tStarts
##         match   match           count   bases   count   bases           name            size    start   end     name            size    start   end     count
## ---------------------------------------------------------------------------------------------------------------------------------------------------------------
## 69      0       0       0       0       0       1       30      +       Query1  69      0       69      Subject1     100     0       99      2       27,42,  0,27,   0,57,
## 69      0       0       0       0       0       1       30      -       Query2  69      0       69      Subject1     100     0       99      2       27,42,  0,27,   0,57

## ELand
## >FC300R4_20080501:1:4:978:119   GCTGTATTGGGTGCTCAGTTTATACTC     U0      1       0       0       chr1.fa 31580563        F

## LAST
## # LAST version 154
##
## a=7 b=1 c=100000 F=-1 e=40 d=24 x=27 y=9 z=27
## u=0 s=2 m=10 l=1 n=4294967295 k=1 i=134217728 w=1000 t=0.910239 g=1 j=3
## AM560_v4
##
##    A  C  G  T
## A  1 -1 -1 -1
## C -1  1 -1 -1
## G -1 -1  1 -1
## T -1 -1 -1  1
##
## Coordinates are 0-based.  For - strand matches, coordinates
## in the reverse complement of the 2nd sequence are used.
##
## score name1   start1  alnSize1        strand1 seqSize1        name2   start2  alnSize2        strand2 seqSize2        blocks
##
## 8324    scaffold08265   1605150 8553    +       4678622 Ctg2558_GC=37.68_Lennogap=8505_Length=8505      0       8505    +       8505    1769,0:4,81,0:1,514,9:0,107,12:0,1943,0:8,2885,12:0,812,16:0,196,12:0,185

## Alignment	MAQ	SOAP2	BWA	BOWTIE	BLAST-psl	Eland
## chromosome	1	7	2	2	13		6
## position	2	8	3	3	15		7
## reads_length	13	5	null	null	10		null
## sequence	14	1	9	4	null		1

$Ref ||= "subject";
my ($i,$j,$k);
my $alignment=$ARGV[0];
my $test=0;
if ($Format =~ /MAQ/i)
{
	open (TEST,$alignment) || die $!;
	$_=<TEST>;
	my @t=split /\t+/,$_;
	$test=1 if (@t!=16);
	close TEST;
	($i,$j,$k)=(1,2,13);
}
elsif ($Format =~ /SOAP/i)
{
	($i,$j,$k)=(7,8,5);
}
elsif (($Format =~ /BWA/i)||($Format =~ /SAM/i)||($Format =~ /BOWTIE/i)||($Format =~ /BAM/i))
{
	$test=2;
	($i,$j,$k)=(2,3,100);
}
elsif ($Format =~ /BLAST/i)
{
	($i,$j,$k)=(13,15,10);
}
elsif ($Format =~ /Eland/i)
{
	($i,$j,$k)=(6,7,100);
}
else
{
	die "This format of file is not available\n" unless ($Format =~ /BLAST/i);
}

my %LGC;
if ((defined $Lengc)&&($Format !~ /BLAT-psl/i))
{
	open (IN,$Lengc) || die $!;
	while (<IN>)
	{
		chomp;
		next if ($_ eq "");
		if ($_ =~ /^(\S+).*Length\:\s+(\d+)/)
		{
			my $name=$1;
			$name=~s/^\>//;
			$name=~s/[\|\;\,\:\-\_]+$//;
			if ($_=~/Lennogap\=(\d+)/)
			{
				$LGC{$name}=$1;
			}
			elsif ($_=~/[^-]Length\:\s+(\d+)/)
			{
				$LGC{$name}=$1;
			}
			elsif ($_=~/Length\:\s+(\d+)/)
			{
				$LGC{$name}=$1;
			}
		}
		elsif($_ =~ /Total\s+Length\:\s+(\d+)/)
		{
			$Length=$1;
		}
		elsif($_ =~ /total\s+value\:\s+(\S+)/)
		{
			$Length=$1;
			if ($Length=~/\d+/)
			{
				$Length=~s/\,//g if ((defined $Length)&&($Length ne ""));
			}
		}
		elsif ($_ =~ /total\:\s+\d+/)
		{
			if ($_=~/([\,\d]+)\s+[\,\d]+$/)
			{
				$Length=$1;
				$Length=~s/\,//g if ((defined $Length)&&($Length ne ""));
			}
		}
	}
	close IN;
}

if ((defined $Sort)&&($Format !~ /BLAST-m8/i)&&($Format !~ /MAQ/i)&&($Format !~ /BAM/i))
{
	my $tmp=$alignment.".sort";
	my $I=$i+1;
	my $J=$j+1;
	if ($Format =~ /BLAST-m0/i)
	{
		$tmp.=$alignment.".sam.sort";
		$Format="SAM";
		system "blast2sam.pl $alignment| msort -k $I,n$J > $tmp" unless (-f $tmp);
	}
	else
	{
		system "msort -k $I,n$J $alignment > $tmp" unless (-f $tmp);
	}
	$alignment=$tmp;
}
if (-f "$alignment.sort")
{
	$alignment.=".sort";
}

my @gap_blocksize_array=();
my @aln_len_array=();
my $consensus_len_report;
my $gap_block_size_report;
if (defined $Stat_report)
{
	$consensus_len_report="$Stat_report.aln_consensus_len_report.stat";
	$gap_block_size_report="$Stat_report.aln_gap_block_size_report.stat";
}
my $aln_len_s=0;
my $aln_len_e=0;

if (($Format =~ /BLAST/i)&&($Format =~ /m8/i))
{
	print "RefSeqID\tRegions\tMatchSequences\tMatchLength\tAlignmentLength\tMismatches\tgaps_openings\tGap_blocks\tGap_blockSize\tHitLocs\tMatchRate(%)\tCoverageRate(%)\n";
	if ($Ref=~/subject/i)
	{
		open (IN,"sort -k 2 $alignment|");
	}
	else
	{
		if (defined $Sort)
		{
			open (IN,"sort -k 1 $alignment|");
		}
		else
		{
			open (IN,$alignment);
		}
	}
	my ($S,$E)=("","");
	my $pre_ref="";
	my ($Regions_num,$Seqs_num,$Match_len,$Aln_len,$Mis_num,$Gaps_num,$Gap_blocks,$Gap_size,$Hit_locs)=(0,0,0,0,0,0,0,0,0);
	my ($query,$subject,$aln_len,$mis,$gap,$q_s,$q_e,$s_s,$s_e);
	my %Hit_Region=();
	my %Hit_Seq=();
	my %Hit_pos=();
	my %Tot_Subject=();
	my %Tot_Query=();
	my ($Tot_locs,$Tot_match,$Tot_reads,$Tot_length,$Tot_mis,$Tot_gap,$Tot_gapb,$Tot_gapbsize)=(0,0,0,0,0,0,0,0);
	while (<IN>)
	{
		my @col=split /\t+/,$_;
		next if (@col<10);
		($query,$subject,$aln_len,$mis,$gap,$q_s,$q_e,$s_s,$s_e)=@col[0,1,3..9];
		$subject=~s/[\|\;\,\:\-\_]+$//;
		$query=~s/[\|\;\,\:\-\_]+$//;
		if ($Ref=~/query/i)
		{
			my $tmp=$subject;
			$subject=$query;
			$query=$tmp;
			$s_s=$q_s;
			$s_e=$q_e;
		}
		if (($pre_ref ne "")&&($pre_ref ne $subject))
		{
			my $length=$E;
			stat_blast(($pre_ref,$S,$E,$Aln_len,$Mis_num,$Gaps_num,\$length,\$Regions_num,\$Seqs_num,\$Match_len,\$Gap_blocks,\$Gap_size,\$Hit_locs,\%Hit_Region,\%Hit_Seq,\%Hit_pos));
			print ("$pre_ref\t",(join "\t",($Regions_num,$Seqs_num,$Match_len,$Aln_len,$Mis_num,$Gaps_num,$Gap_blocks,$Gap_size,$Hit_locs)),"\t");
			print ((int(10000*$Match_len/$Hit_locs+0.5)/100),"\t",(int(10000*$Hit_locs/$length+0.5)/100),"\n");
			$Tot_locs+=$Hit_locs;
			$Tot_match+=$Match_len;
			$Tot_length+=$length;
			$Tot_mis+=$Mis_num;
			$Tot_gap+=$Gaps_num;
			$Tot_gapb+=$Gap_blocks;
			$Tot_gapbsize+=$Gap_size;
			($Regions_num,$Seqs_num,$Match_len,$Aln_len,$Mis_num,$Gaps_num,$Gap_blocks,$Gap_size,$Hit_locs)=(0,0,0,0,0,0,0,0,0);
			delete @Hit_Region{keys %Hit_Region};
			delete @Hit_Seq{keys %Hit_Seq};
			delete @Hit_pos{keys %Hit_pos};
			($S,$E)=("","");
		}
		my ($s,$e)=($s_s<$s_e)?($s_s,$s_e):($s_e,$s_s);
		if (($S eq "")||($S>=$s))
		{
			$S=$s;
		}
		if (($E eq "")||($E<=$e))
		{
			$E=$e;
		}
		for (my $p=$s;$p<=$e;$p++)
		{
			$Hit_pos{$p}++;
		}
		$Aln_len+=$aln_len;
		$Mis_num+=$mis;
		$Gaps_num+=$gap;
		$Hit_Region{"$subject-$s-$e"}++;
		$Hit_Seq{$query}++;
		$pre_ref=$subject;
		$Tot_Subject{$subject}=1;
		$Tot_Query{$query}=1;
	}
	my $length=$E;
	stat_blast(($pre_ref,$S,$E,$Aln_len,$Mis_num,$Gaps_num,\$length,\$Regions_num,\$Seqs_num,\$Match_len,\$Gap_blocks,\$Gap_size,\$Hit_locs,\%Hit_Region,\%Hit_Seq,\%Hit_pos));
	$Tot_locs+=$Hit_locs;
	$Tot_match+=$Match_len;
	$Tot_length+=$length;
	$Tot_mis+=$Mis_num;
	$Tot_gap+=$Gaps_num;
	$Tot_gapb+=$Gap_blocks;
	$Tot_gapbsize+=$Gap_size;
	print ("$pre_ref\t",(join "\t",($Regions_num,$Seqs_num,$Match_len,$Aln_len,$Mis_num,$Gaps_num,$Gap_blocks,$Gap_size,$Hit_locs)),"\t");
	print ((int(10000*$Match_len/$Hit_locs+0.5)/100),"\t",(int(10000*$Hit_locs/$length+0.5)/100),"\n");
	close IN;
	my $aln_len_n50=stat_n50($Tot_match,\@aln_len_array,$consensus_len_report);
	my $gap_blocksize_n50=stat_n50($Tot_gapbsize,\@gap_blocksize_array,$gap_block_size_report);
print ("\n This alignment reports $Tot_locs locs in ",scalar(keys %Tot_Subject)," ref sequences covered by $Tot_match bases of ",scalar(keys %Tot_Query)," sequences\n");
print (" The average value of covered locs' coverage is: ",$Tot_match/$Tot_locs,"\n");
print (" The whole covered reference average value of coverage is: ",$Tot_match/$Tot_length,"\n");
print (" There are $Tot_mis mismatch locs in the covered sequences\n");
print (" There are $Tot_gap inner gaps in the covered sequence, $Tot_gapb gaps blocks in the covered sequences, the total gaps blockSize is: $Tot_gapbsize\n");
print " The N50 of match blocks size is: $aln_len_n50; The N50 of gaps blocks size is: $gap_blocksize_n50\n";
	exit();
}
elsif (($Format =~ /BLAT/i)&&($Format =~ /psl/i))
{
	my ($match,$mismatch,$repmatch,$Ns,$Qgap_count);
	my ($Qgap_bases,$Tgap_count,$Tgap_bases,$strand,$Qname);
	my ($Qsize,$Q_S,$Q_E,$Tname,$Tsize);
	my ($T_S,$T_E,$block_count,@blockSizes,@q_S,@t_S);
	my ($query,$subject);
	my %Pos=();
	my ($Bases,$Reads)=(0,0);
	my ($Tot_pos,$Tot_bases,$Tot_reads,$Tot_length,$Tot_gaps,$Tot_gap_len,$Tot_mis,$Tot_rep,$Tot_Ns)=(0,0,0,0,0,0,0,0,0);
	my ($Gap_count,$Gap_len)=(0,0);
	print "RefSeqName\tLocs\tFrom\tTo\tBases\tReads\tCovBaseAvg\tCoverageAvg\tMismatchs\tRep-match\tNs\tGaps\tGaps\'Length\tCoverageRate(%)\n";
	open (IN,$alignment) || die $!;
	while(<IN>)
	{
		chomp;
		my @t=split /\t+/;
		next if ((@t<=20)||($t[8] !~ /[\+\-]/));
		$t[$i]=~s/[\|\;\,\:\-\_]+$//;
		if ((!defined $Tname)||((defined $Tname)&&($Tname ne $t[$i])))
		{
			if (defined $Tname)
			{
				my @pos_array=sort{$a<=>$b}keys %Pos;
				my $positions=@pos_array;
				$Tot_pos+=$positions;
				$Tot_bases+=$Bases;
				$Tot_reads+=$Reads;
				$Tot_length+=$Tsize;
				$Tot_mis+=$mismatch;
				$Tot_rep+=$repmatch;
				$Tot_Ns+=$Ns;
				my $pre=0;
				for (my $p=0;$p<@pos_array;$p++)
				{
					if ($pos_array[$p]>$pre+1)
					{
						$aln_len_e=$pre;
						push @aln_len_array,($aln_len_e-$aln_len_s+1);
						$Gap_count++;
						if ($pre==0)
						{
							$Gap_len+=$pos_array[$p];
							push @gap_blocksize_array,$pos_array[$p];
						}
						else
						{
							$Gap_len+=$pos_array[$p]-$pre-1;
							push @gap_blocksize_array,($pos_array[$p]-$pre-1);
						}
						$aln_len_s=$pos_array[$p];
					}
					$pre=$pos_array[$p];
				}
				if ($pos_array[-1]!=$T_E)
				{
					$Gap_count++;
					$Gap_len+=$T_E-$pos_array[-1]-1;
					push @gap_blocksize_array,$T_E-$pos_array[-1]-1;
				}
				$Tot_gaps+=$Gap_count;
				$Tot_gap_len+=$Gap_len;
				my $Cov1=sprintf("%.4f",$Bases/$positions);
				my $Cov2=sprintf("%.4f",$Bases/$Tsize);
				my $CovRate=sprintf("%.4f",100*$positions/$Tsize);
				print "$Tname\t$positions\t$T_S\t$T_E\t$Bases\t$Reads\t$Cov1\t$Cov2\t$mismatch\t$repmatch\t$Ns\t$Gap_count\t$Gap_len\t$CovRate\%\n";
			}

			$Q_S=$t[($Ref=~/subject/i)?11:15];
			$T_S=$t[($Ref=~/subject/i)?15:11];

			($mismatch,$repmatch,$Ns,$Qgap_count,$Qgap_bases,$Tgap_count,$Tgap_bases)=(0,0,0,0,0,0);
			%Pos=();
			delete @Pos {keys %Pos};
			($Bases,$Reads)=(0,0);
			($Gap_count,$Gap_len)=(0,0);
		}

		$Reads++;
		$mismatch+=$t[1];
		$repmatch+=$t[2];
		$Ns+=$t[3];

		$Qgap_count+=$t[($Ref=~/subject/i)?4:6];
		$Qgap_bases+=$t[($Ref=~/subject/i)?5:7];
		$Tgap_count+=$t[($Ref=~/subject/i)?6:4];
		$Tgap_bases+=$t[($Ref=~/subject/i)?7:5];

		$strand=$t[8];

		$Qname=$t[($Ref=~/subject/i)?9:13];
		$Qsize=$t[($Ref=~/subject/i)?10:14];
		$Q_E=$t[($Ref=~/subject/i)?12:16];
		$Tname=$t[($Ref=~/subject/i)?13:9];
		$Tsize=$t[($Ref=~/subject/i)?14:10];
		$T_E=$t[($Ref=~/subject/i)?16:12];

		$block_count=$t[17];
		$t[18]=~s/\,$//;
		@blockSizes=split /\,/,$t[18];
		$t[19]=~s/\,$//;
		$t[20]=~s/\,$//;
		@q_S=split /\,/,$t[($Ref=~/subject/i)?19:20];
		@t_S=split /\,/,$t[($Ref=~/subject/i)?20:19];

		for (my $i=0;$i<$block_count;$i++)
		{
			my ($S,$E)=($t_S[$i],$t_S[$i]+$blockSizes[$i]);
			map{$Pos{$_}++;$Bases++}($S..$E);
		}
	}
	my @pos_array=sort{$a<=>$b}keys %Pos;
	my $positions=@pos_array;
	$Tot_pos+=$positions;
	$Tot_bases+=$Bases;
	$Tot_reads+=$Reads;
	$Tot_length+=$Tsize;
	$Tot_mis+=$mismatch;
	$Tot_rep+=$repmatch;
	$Tot_Ns+=$Ns;
	my $pre=0;
	for (my $p=0;$p<@pos_array;$p++)
	{
		if ($pos_array[$p]>$pre+1)
		{
			$aln_len_e=$pre;
			push @aln_len_array,($aln_len_e-$aln_len_s+1);
			$Gap_count++;
			if ($pre==0)
			{
				$Gap_len+=$pos_array[$p];
				push @gap_blocksize_array,$pos_array[$p];
			}
			else
			{
				$Gap_len+=($pos_array[$p]-$pre-1);
				push @gap_blocksize_array,($pos_array[$p]-$pre-1);
			}
			$aln_len_s=$pos_array[$p];
		}
		$pre=$pos_array[$p];
	}
	if ($pre!=$T_E)
	{
		$Gap_count++;
		$Gap_len+=$T_E-$pos_array[-1]-1;
		push @gap_blocksize_array,$T_E-$pos_array[-1]-1;
	}
	$Tot_gaps+=$Gap_count;
	$Tot_gap_len+=$Gap_len;
	my $Cov1=sprintf("%.4f",$Bases/$positions);
	my $Cov2=sprintf("%.4f",$Bases/$Tsize);
	my $CovRate=sprintf("%.4f",100*$positions/$Tsize);
	print "$Tname\t$positions\t$T_S\t$T_E\t$Bases\t$Reads\t$Cov1\t$Cov2\t$mismatch\t$repmatch\t$Ns\t$Gap_count\t$Gap_len\t$CovRate\%\n";
	close IN;
	my $aln_len_n50=stat_n50($Tot_pos,\@aln_len_array,$consensus_len_report);
	my $gap_blocksize_n50=stat_n50($Tot_gap_len,\@gap_blocksize_array,$gap_block_size_report);
	print "\nThis alignment reports $Tot_pos locs covered by $Tot_length bases of $Tot_reads reads\n";
	print ("The average value of covered locs' coverage is: ",$Tot_bases/$Tot_pos,"\n");
	print ("The whole covered reference average value of coverage is: ",$Tot_bases/$Tot_length,"\n");
	print ("There are $Tot_mis mismatch locs and $Tot_rep rep. match in the covered sequences\n");
	print ("There are $Tot_Ns N's bases in the covered sequences\n");
	print ("There are $Tot_gaps gaps in the covered sequences, the total gaps' length is: $Tot_gap_len\n");
	print " The N50 of match blocks size is: $aln_len_n50; The N50 of gaps blocks size is: $gap_blocksize_n50\n";
	exit();
}

my ($chr,$chr_num,$pos,$base,$pre,$Gap_Num,$Gap_Len)=("BENM",0,0,0,0,0,0);
my ($temp_pos,$temp_base,$gap_num,$gap_len)=(0,0,0,0);
my ($reads,$tot_reads)=(0,0);
my ($S,$E)=(0,0);
if (!defined $Lengc)
{
	print "RefSeqName\tRefLength\tLocs\tFrom\tTo\tBases\tReads\tCovBaseAvg\tCoverageAvg\tGaps\tGaps\'Length(not-include-tail-gap)\tCoverageRate(%)\n";
}
else
{
	print "RefSeqName\tRefLength\tLocs\tFrom\tTo\tBases\tReads\tCovBaseAvg\tCoverageAvg\tGaps\tGaps'Length\tCoverageRate(%)\n";
}
open (IN,$alignment) if ($test==0);
open (IN,"maq mapview $alignment|") if ($test==1);
open (IN,"samtools view -h $alignment|") if ($test==2);
while(<IN>)
{
	chomp;
	my @t=split /\t+/,$_;
	$t[$i] = ((defined $Lengc)&&($Format=~ /BOWTIE/i)) ? (split /\s/,$t[$i])[0] : $t[$i];
#@SQ     SN:W14_V6.2.ctg000001|Length=5821|GC=26.78      LN:5821
	if ((!defined $Lengc)&&(($Format=~/SAM/i)||($Format=~/BAM/i)||($Format=~/BWA/i)||($Format=~/BOWTIE/i))&&(/^\@SQ/))
	{
		$LGC{$1}=$2 if (/SN\:(\S+)\s+LN\:(\d+)/);
		next;
	}
	next if ((/^\#/)||((($Format=~/SAM/i)||($Format=~/BAM/i))&&(/^\@/)));
	next if ((($Format=~/SAM/i)||($Format=~/BAM/i)||($Format=~/BWA/i)||($Format=~/BOWTIE/i))&&((/^\@/)||(@t<10)||($t[2] eq "*")||($t[3] eq "*")));
	$t[$i]=~s/[\|\;\,\:\-\_]+$//;
	next if ((!defined $t[$i])||($t[$i] eq ""));
	if ($k==100)
	{
		if (($Format =~ /BWA/i)||($Format =~ /SAM/i)||($Format =~ /BAM/i))
		{
			next if ($t[5] =~ /^\*/);
			$t[$k] = $1 if ($t[5] =~ /(\d+)M/);
		}
		elsif ($Format =~ /BOWTIE/i)
		{
			$t[$k] = length($t[4]);
		}
		elsif ($Format =~ /Eland/i)
		{
			$t[$k] = length($t[1]);
		}
	}
	if ($chr ne $t[$i])
	{
		$pos+=$t[$k];
		$base+=$t[$k];
		push @aln_len_array,($aln_len_e-$aln_len_s+1) if ($aln_len_e-$aln_len_s+1>0);
		$aln_len_s=$t[$j];
		$aln_len_e=$t[$j]+$t[$k]-1;
		if ((defined $Lengc)&&($chr ne "BENM"))
		{
			if ($LGC{$chr}-$E>0)
			{
				$gap_num+=1;
				$gap_len+=$LGC{$chr}-$E;
				push @gap_blocksize_array,$LGC{$chr}-$E;
			}
		}
		$Gap_Num+=$gap_num;
		$Gap_Len+=$gap_len;
		if ($chr ne "BENM")
		{
			my $Cov1 = sprintf("%.4f",$temp_base/$temp_pos);
			my $len_denominator=((defined $Lengc)||(exists $LGC{$chr}))?$LGC{$chr}:$E;
			my $Cov2 = sprintf("%.4f",$temp_base/$len_denominator);
			my $CovRate = int(10000*($len_denominator-$gap_len)/$len_denominator+0.5)/100;
			print ("$chr\t$len_denominator\t$temp_pos\t$S\t$E\t$temp_base\t$reads\t$Cov1\t$Cov2\t$gap_num\t$gap_len\t$CovRate%\n");
			$chr_num++;
		}
		$temp_pos=$t[$k];
		$temp_base=$t[$k];
		$gap_num = ($t[$j]==1) ? 0 : 1;
		$gap_len = ($t[$j]==1) ? 0 : ($t[$j]-1);
		push @gap_blocksize_array,$gap_len if ($gap_len>0);
		$Gap_Num+=$gap_num;
		$Gap_Len+=$gap_len;
		$tot_reads+=$reads;
		$reads=0;
		$S=$t[$j];
	}
	else
	{
		if (($t[$j]+$t[$k]-1-$pre>=0)&&($t[$j]-$pre<=0))
		{
			$pos+=$t[$j]+$t[$k]-1-$pre;
			$base+=$t[$k];
			$temp_pos+=$t[$j]+$t[$k]-1-$pre;
			$temp_base+=$t[$k];
			$aln_len_e=$t[$j]+$t[$k]-1;
		}
		elsif ($t[$j]+$t[$k]-1-$pre<0)
		{
			$base+=$t[$k];
			$temp_base+=$t[$k];
			$reads++;
			$aln_len_e=($aln_len_e>$t[$j]+$t[$k]-1)?$aln_len_e:($t[$j]+$t[$k]-1);
			$chr=$t[$i];
			$reads++;
			$E=($t[$j]+$t[$k]-1>$E)?$t[$j]+$t[$k]-1:$E;
			next;
		}
		elsif ($t[$j]>$pre)
		{
			$aln_len_e=$t[$j]+$t[$k]-1;
			push @aln_len_array,($aln_len_e-$aln_len_s+1) if ($aln_len_e-$aln_len_s+1>0);
			$aln_len_s=$t[$j];
			$aln_len_e=$t[$j]+$t[$k]-1;
			$gap_num+=1 if ($t[$j]-$pre>1);
			$gap_len+=$t[$j]-$pre-1;
			push @gap_blocksize_array,$t[$j]-$pre-1;
			$pos+=$t[$k];
			$base+=$t[$k];
			$temp_pos+=$t[$k];
			$temp_base+=$t[$k];
		}
	}
	$chr=$t[$i];
	$pre=$t[$j]+$t[$k]-1;
	$reads++;
	$E=$t[$j]+$t[$k]-1;
}
$tot_reads+=$reads;
push @aln_len_array,($aln_len_e-$aln_len_s+1) if ($aln_len_e-$aln_len_s+1>0);
if ((defined $Lengc)&&($LGC{$chr}-$E>0))
{
	$gap_num+=1;
	$gap_len+=$LGC{$chr}-$E;
}
$Gap_Num+=$gap_num;
$Gap_Len+=$gap_len;
my $cov1 = sprintf("%.4f",$temp_base/$temp_pos);
my $cov2 = (defined $Lengc) ? sprintf("%.4f",$temp_base/$LGC{$chr}) : sprintf("%.4f",$temp_base/$E);
my $cov_rate = (defined $Lengc) ? int(10000*($LGC{$chr}-$gap_len)/$LGC{$chr}+0.5)/100 : int(10000*($E-$gap_len)/$E+0.5)/100;
print ("$chr\t$temp_pos\t$S\t$E\t$temp_base\t$reads\t$cov1\t$cov2\t$gap_num\t$gap_len\t$cov_rate%\n");
$chr_num++;
my $aln_len_n50=stat_n50($temp_pos,\@aln_len_array,$consensus_len_report);
my $gap_blocksize_n50=stat_n50($gap_len,\@gap_blocksize_array,$gap_block_size_report);
print "\nThis alignment reports $pos locs of $chr_num ref sequences covered by $base bases of $tot_reads reads\n";
print ("The average value of covered locs' coverage is: ",$base/$pos,"\n");
print ("The whole covered reference average value of coverage is: ",$base/$Length,"\n") if ((defined $Length)&&($Length>0));
print ("There are $Gap_Num gaps in the covered sequences, the total gaps' length is: $Gap_Len\n");
print " The N50 of match blocks size is: $aln_len_n50; The N50 of gaps blocks size is: $gap_blocksize_n50\n";
close IN;

sub stat_blast
{
	my ($subject,$S,$E,$Aln_len,$Mis_num,$Gaps_num,$length_p,$Regions_num,$Seqs_num,$Match_len,$Gap_blocks,$Gap_size,$Hit_locs,$Hit_Region,$Hit_Seq,$Hit_pos)=@_;
	$$Regions_num=keys %$Hit_Region;
	$$Seqs_num=keys %$Hit_Seq;
	$$Hit_locs=keys %$Hit_pos;
	#$$Match_len=$Aln_len-$Mis_num-$Gaps_num;
	$$Match_len=0;
	my $pre_p=0;
	my $tmp_s=1;
	if ($S>1)
	{
		$pre_p=$S;
		$$Gap_blocks=1;
		$$Gap_size=$S-1;
		if ($$Gap_size>0)
		{
			push @gap_blocksize_array,$$Gap_size;
		}
	}
	foreach my $p(sort{$a<=>$b}keys %$Hit_pos)
	{
		$tmp_s=$p if ($tmp_s==1);
		if ($p>$pre_p+1)
		{
			$$Match_len+=$pre_p-$tmp_s+1;
			push @aln_len_array,$pre_p-$tmp_s+1;
			$$Gap_size=$p-$pre_p-1;
			if ($$Gap_size>0)
			{
				push @gap_blocksize_array,$$Gap_size;
				$$Gap_blocks++;
			}
			$tmp_s=$p;
		}
		$pre_p=$p;
	}
	if ($pre_p>$tmp_s)
	{
		$$Match_len+=$pre_p-$tmp_s+1;
		push @aln_len_array,$pre_p-$tmp_s+1;
	}
	if ((defined $Lengc)&&(!exists $LGC{$subject}))
	{
		warn "$subject no length info, use the end position: $E as the length of it\n";
	}
	else
	{
		$$length_p=$LGC{$subject};
	}
	if ($E<$$length_p)
	{
		$$Gap_blocks++;
		$$Gap_size=$$length_p;
		if ($$Gap_size>0)
		{
			push @gap_blocksize_array,$$Gap_size;
			$$Gap_blocks++;
		}
	}
}

sub stat_n50
{
	my ($tot,$array_p,$file)=@_;
	my ($count,$n50)=(0,0);
	my %stat;
	foreach my $k ( sort {$b<=>$a} @$array_p)
	{
		$stat{$k}++;
		$count+=$k;
		if (($count>=$tot/2)&&($n50==0))
		{
			$n50=$k;
			last unless (defined $file);
		}
	}
	if (defined $file)
	{
		open (OUT,">$file") || die $!;
		foreach my $k(sort{$a<=>$b}keys %stat)
		{
			print OUT "$k\t$stat{$k}\n";
		}
		close OUT;
	}
	return $n50;
}
